# Design-Doc: Чат-бот / RAG-система

/ основан на шаблоне команды [Reliable ML](https://github.com/IrinaGoloshchapova/ml_system_design_doc_ru/blob/main/ML_System_Design_Doc_Template.md) /

(Заполняется проектной командой: бизнес-заказчик, ML/инженеры, продуктовая команда)

## 1. Контекст проекта

### 1.1 Бизнес-задача
	•	Описание проблемы/вызова, который пытаемся решить (например: ускорение ответа операторов, автоматизация FAQ, повышение удовлетворённости клиентов).
	•	Почему именно чат-бот / RAG-система имеет смысл.
	•	Каковы критерии успеха с точки зрения бизнеса.

Если у нас есть готовое решение, то мы говорим об улучшении текущего опыта; лучше не говорить напрямую о том, что вы хотите сократить штат и кого-то уволить, даже если это правда ваша цель (пожалуйста, думайте об этике). Если решения нет, то надо решение оправдать.

Во введении / актуальности работы: почему без чат-бота не справиться?

На третий вопрос не обязательно отвечать в рамках работы, но важно хотя бы представлять, как будет измеряться успешность исполнения задачи и успешность самого решения. "что мы считаем успехом".

### 1.2 Целевая аудитория и пользователи
	•	Кто будет пользоваться ботом: внутренние сотрудники, клиенты, партнёры.
	•	Какие сценарии использования: текстовый чат, голосовой интерфейс, мессенджеры, веб-виджет.
	•	Какова предполагаемая нагрузка: число сессий/пользователей, пиковые часы.

Вопрос в цене ошибки, + вопрос в пользовательских сценариях и их поведении. Из-за того, с кем мы общаемся и где мы общаемся, мы можем варьировать как контент на входе, так и на выходе.

### 1.3 Ограничения и допущения
	•	Что нельзя/не будет делать (например: не интегрируемся с X, не обрабатываем Y).
	•	Предположения о данных, инфраструктуре, требованиях к безопасности, к нормативам.

Про: репутационные риски, хотим ли мы отвечать на вопросы не по предметной области чат-бота?

## 2. Архитектура решения

### 2.1 Общая схема
	•	Диаграмма архитектуры: фронт-энд (чат-интерфейс) → API → RAG-движок → база/хранилище знаний → LLM → пост-обработка.
	•	Основные компоненты и их роли.

Буду спрашивать со всех: где лежит бд, когда мы в неё стучимся, где лежит промпт, в каком порядке обрабатываем пользовательские запросы?

### 2.2 Хранилище знаний / документооборот
	•	Источники знаний: внутренние документы, база знаний, Wiki, чаты, внешние API.
	•	Предобработка: парсинг, нормализация, категоризация.
	•	Индексация: векторизация (embedding), ключевые слова, метаданные.
	•	Обновление данных: как часто синхронизируется, как обрабатываются новые документы.

Как часто обновляем данные? Где храним? Что храним? в каком виде? Где оно лежит, если нужно будет обновить? (Парсинг или ручное обновление)

### 2.3 Retrieval + Generation
	•	Retrieval: какой движок (Qdrant, FAISS, Elastic Vectorembedding и т.д.), конфигурации (embedding модель, размер векторов, k, threshold).
	•	Generation: какая LLM используется (локально / облако), с какими промпт-шаблонами.
	•	Контроль ответа: фильтрация, шаблоны, гарантия качества, fallback стратегия.
-- технические решения, можно к КТ1 не писать, но просто прикинуть, что будет актуально; но аргументировать выбор перед защитой на основе бизнес-требований.

### 2.4 Интеграции и интерфейсы
	•	Внешние API и сервисы: чат-интерфейс, CRM, база пользователей, логирование.
	•	Протоколы: REST, gRPC, WebSockets, Webhook.
	•	UI/UX: как выглядит чат, переходы, кнопки, предложения.
	•	Мониторинг: логирование запросов/ответов, аналитика, алерты.

### 2.5 Инфраструктура и развертывание
	•	Архитектурный стек: контейнеры (Docker), оркестрация (Kubernetes), серверless.
	•	Среды: dev/test/prod.
	•	Требования к вычислениям: GPU или CPU, память, хранилище.
	•	Безопасность: аутентификация, авторизация, шифрование, GDPR/нормы.
	•	Масштабирование: горизонтальное, резервирование, локализация.

## 3. Данные и качество знаний

Пометка: содежат ли документы чувствительные данные (можно ли это отправлять "во вне", например, в GPT, или можно только локальные модели; может быть придётся замаскировать данные?)

### 3.1 Сбор и предобработка данных
	•	Источники документов/текста, форматы (PDF, HTML, TXT, базы данных).
	•	Шаги предобработки: токенизация, очистка, выделение сущностей, сегментация.
	•	Метаданные: добавление тегов, категоризация, дата, автор.

### 3.2 Векторизация и индексирование
	•	Модель embedding: название, версия, особенности (например multiling, domain-specific).
	•	Параметры индекса: размер, алгоритм, метрики (cosine, euclid), shards/replicas.
	•	Стратегии обновления: инкрементальное обновление, пересборка индекса.

### 3.3 Метрики качества знаний
	•	Покрытие: % документов в базе относящихся к сценариям.
	•	Актуальность: как быстро база обновляется, как отражаются изменения.
	•	Консистентность: нет дубликатов, нет противоречивых данных.
	•	Проверка: ручная ревизия, спотыкаемые примеры, A/B-тестирование.

## 4. Модель и генерация

### 4.1 Выбор LLM и промптинг
	•	Указание модели: объяснение, почему выбранa.
	•	Промпт-шаблоны: входные данные, контекст, инструкции, формат ответа.
	•	Ограничения: максимальная длина, токены, скорость генерации.

### 4.2 Контроль качества ответов
	•	Метрики: точность, полнота/coverage, полезность, удовлетворённость пользователя.
	•	Оценка ошибок: нежелательные ответы, hallucinations, офтопик.
	•	Механизмы: ручной ревью, эвристики (например “если confidence < x, дефолтный ответ”), fallback на статический контент.

### 4.3 Обучение/дообучение
	•	Если предусмотрено fine-tuning или RLHF: данные, процесс, метрики.
	•	Версионирование моделей, rollback план.

## 5. UX / пользовательский опыт

Важно: пункт 5.1 -- он определяет частично БФТ. Что делать, если не смогли ответить? Продумать, где мы можем накосячить и как это обработать?

### 5.1 Сценарии взаимодействия
	•	Основные сценарии: приветствие, поиск по знаниям, уточняющий вопрос, многотуровый диалог.
	•	Исключительные сценарии: нет ответа, не поняли, баг, перенос к оператору.

### 5.2 Диалоговая логика
	•	Как обрабатываются состояния: single-turn, multi-turn.
	•	Как ведётся контекст: окно истории, память пользователя.
	•	Как эстетически выглядят ответы (тон, стиль, язык, эмодзи/микроинтеракции).
Храним ли мы историю общения с пользователем? Если да, то как? В каком тоне отвечаем?

### 5.3 Метрики UX
	•	Время до первого ответа, % возврата пользователей, NPS, рейтинг полезности ответа.
	•	Логирование взаимодействий, сбор отзывов.
Как быстро нужно отвечать? Может быть надо как-то взаимодействовать с пользователем в рамках получения фидбэка (лайк/дизлайк). Нужно ли логгировать работу бота для отслеживания качества работы?

## 6. Безопасность, соответствие и этика
	•	Обработка персональных данных, разрешения пользователей.
	•	Устранение вредоносного/нежелательного контента, фильтры.
	•	Прозрачность: уведомление о том, что это бот, логика сбора данных.
	•	Регулирования и нормативы (GDPR, внутренние политики).

## [OPTIONAL] 7. План внедрения и эксплуатации

Скорее актуально для рабочего проекта и его запуска.
### 7.1 Этапы проекта
	•	Фаза 0: исследование/документирование.
	•	Фаза 1: MVP (минимально жизнеспособный бот).
	•	Фаза 2: расширение функциональности, RAG-дополнения.
	•	Фаза 3: масштабирование, оптимизация.
	•	Вехи, сроки, ответственные.

### 7.2 Поддержка и эксплуатация
	•	Кто отвечает за поддержку (SRE, DevOps, чат-бот команда).
	•	Мониторинг: логирование ошибок, SLA, alerts, dashboards.
	•	Обновление знаний: план синхронизации, процесс ревью.
	•	Метрики эксплуатации: uptime, latency, cost per session.

## 8. Риски и допущения
	•	Список основных рисков (например: модель даёт неточные ответы, база знаний недостаточна, бюджет/ресурсы ограничены).
	•	Вероятность и влияние, стратегия уменьшения (mitigation).
	•	Ключевые допущения, которые не проверены.

## 9. [OPTIONAL] Бюджет и ресурсы
Скорее актуально для рабочего проекта и его запуска.
	•	Человеческие ресурсы: ML инженер, NLP инженер, DevOps, UX дизайнер, контент-менеджер.
	•	Технологические ресурсы: вычислительные ресурсы (GPU/CPU), лицензии, облачные сервисы.
	•	Примерные затраты (CAPEX, OPEX).
	•	ROI оценки: ожидаемое снижение затрат, ускорение ответа, рост удовлетворённости.

## 10. Приложения
Что-то, что стоит прописать в тексте работы во введении.
	•	Словарь терминов и аббревиатур.
	•	Ссылки на специфические документы: требования безопасности, регламент, UX-гайд, API-спецификации.
	•	Диаграммы, схемы, mock-up интерфейсов.
	•	Чек-лист готовности к запуску.
